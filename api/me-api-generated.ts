/* tslint:disable */
/* eslint-disable */
/*
SoundCloud Public API Specification

Discover and play over 320 million music tracks. Join the worldâ€™s largest online community of artists, bands, DJs, and audio creators.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Activities } from '../models';
// @ts-ignore
import { Me } from '../models';
// @ts-ignore
import { MeGetLikedPlaylistsResponse } from '../models';
// @ts-ignore
import { MeListLikedTracksResponse } from '../models';
// @ts-ignore
import { Track } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { Users } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a user who is followed by the authenticated user.
         * @param {number} userId SoundCloud User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFollowedUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteFollowedUser', 'userId', userId)
            const localVarPath = `/me/followings/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/followings/{user_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Follows a user.
         * @param {number} userId SoundCloud User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('followUser', 'userId', userId)
            const localVarPath = `/me/followings/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/followings/{user_id}',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the authenticated user\'s activities.
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities: async (access?: Array<'playable' | 'preview' | 'blocked'>, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/activities',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a user who is followed by the authenticated user. (use /users/{user_id} instead, to fetch the user details)
         * @param {number} userId SoundCloud User id
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getFollowedUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFollowedUser', 'userId', userId)
            const localVarPath = `/me/followings/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/followings/{user_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of users who are followed by the authenticated user.
         * @param {number} [limit] Number of results to return in the collection.
         * @param {number} [offset] Offset of first result. Deprecated, use &#x60;linked_partitioning&#x60; instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowedUsers: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/followings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/followings',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a user who is following the authenticated user. (use /users/{user_id} instead, to fetch the user details)
         * @param {number} followerId SoundCloud User id to denote a Follower
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getFollowerById: async (followerId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followerId' is not null or undefined
            assertParamExists('getFollowerById', 'followerId', followerId)
            const localVarPath = `/me/followers/{follower_id}`
                .replace(`{${"follower_id"}}`, encodeURIComponent(String(followerId !== undefined ? followerId : `-follower_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/followers/{follower_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of users who are following the authenticated user.
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersList: async (limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/followers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of favorited or liked playlists of the authenticated user.
         * @param {number} [limit] Number of results to return in the collection.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikedPlaylists: async (limit?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/likes/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/likes/playlists',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recent the authenticated user\'s activities.
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities: async (access?: Array<'playable' | 'preview' | 'blocked'>, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/activities/all/own`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/activities/all/own',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the authenticated user\'s recent track related activities.
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTracks: async (access?: Array<'playable' | 'preview' | 'blocked'>, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/activities/tracks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/activities/tracks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the authenticated userâ€™s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of recent tracks from users followed by the authenticated user.
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {number} [limit] Number of results to return in the collection.
         * @param {number} [offset] Offset of first result. Deprecated, use &#x60;linked_partitioning&#x60; instead.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFollowedTracks: async (access?: Array<'playable' | 'preview' | 'blocked'>, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/followings/tracks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/followings/tracks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of favorited or liked tracks of the authenticated user.
         * @param {number} [limit] Number of results to return in the collection.
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikedTracks: async (limit?: number, access?: Array<'playable' | 'preview' | 'blocked'>, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/likes/tracks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/likes/tracks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns playlist info, playlist tracks and tracks owner info.
         * @summary Returns userâ€™s playlists (sets).
         * @param {boolean} [showTracks] A boolean flag to request a playlist with or without tracks. Default is &#x60;true&#x60;.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaylistsInfoTracksOwner: async (showTracks?: boolean, linkedPartitioning?: boolean, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (showTracks !== undefined) {
                localVarQueryParameter['show_tracks'] = showTracks;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/playlists',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of user\'s tracks.
         * @param {number} [limit] Number of results to return in the collection.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTracks: async (limit?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/tracks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/me/tracks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a user who is followed by the authenticated user.
         * @param {MeApiDeleteFollowedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFollowedUser(requestParameters: MeApiDeleteFollowedUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFollowedUser(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Follows a user.
         * @param {MeApiFollowUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(requestParameters: MeApiFollowUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the authenticated user\'s activities.
         * @param {MeApiGetActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivities(requestParameters: MeApiGetActivitiesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activities>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActivities(requestParameters.access, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a user who is followed by the authenticated user. (use /users/{user_id} instead, to fetch the user details)
         * @param {MeApiGetFollowedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getFollowedUser(requestParameters: MeApiGetFollowedUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowedUser(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of users who are followed by the authenticated user.
         * @param {MeApiGetFollowedUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowedUsers(requestParameters: MeApiGetFollowedUsersRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowedUsers(requestParameters.limit, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a user who is following the authenticated user. (use /users/{user_id} instead, to fetch the user details)
         * @param {MeApiGetFollowerByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getFollowerById(requestParameters: MeApiGetFollowerByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowerById(requestParameters.followerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of users who are following the authenticated user.
         * @param {MeApiGetFollowersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowersList(requestParameters: MeApiGetFollowersListRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowersList(requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of favorited or liked playlists of the authenticated user.
         * @param {MeApiGetLikedPlaylistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikedPlaylists(requestParameters: MeApiGetLikedPlaylistsRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeGetLikedPlaylistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLikedPlaylists(requestParameters.limit, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Recent the authenticated user\'s activities.
         * @param {MeApiGetRecentActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentActivities(requestParameters: MeApiGetRecentActivitiesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activities>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentActivities(requestParameters.access, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the authenticated user\'s recent track related activities.
         * @param {MeApiGetRecentTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentTracks(requestParameters: MeApiGetRecentTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Activities>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentTracks(requestParameters.access, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the authenticated userâ€™s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Me>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of recent tracks from users followed by the authenticated user.
         * @param {MeApiListFollowedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFollowedTracks(requestParameters: MeApiListFollowedTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Track>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFollowedTracks(requestParameters.access, requestParameters.limit, requestParameters.offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of favorited or liked tracks of the authenticated user.
         * @param {MeApiListLikedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLikedTracks(requestParameters: MeApiListLikedTracksRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeListLikedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLikedTracks(requestParameters.limit, requestParameters.access, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns playlist info, playlist tracks and tracks owner info.
         * @summary Returns userâ€™s playlists (sets).
         * @param {MeApiListPlaylistsInfoTracksOwnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlaylistsInfoTracksOwner(requestParameters: MeApiListPlaylistsInfoTracksOwnerRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeGetLikedPlaylistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlaylistsInfoTracksOwner(requestParameters.showTracks, requestParameters.linkedPartitioning, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of user\'s tracks.
         * @param {MeApiListUserTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserTracks(requestParameters: MeApiListUserTracksRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeListLikedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserTracks(requestParameters.limit, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a user who is followed by the authenticated user.
         * @param {MeApiDeleteFollowedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFollowedUser(requestParameters: MeApiDeleteFollowedUserRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteFollowedUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Follows a user.
         * @param {MeApiFollowUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(requestParameters: MeApiFollowUserRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.followUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the authenticated user\'s activities.
         * @param {MeApiGetActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(requestParameters: MeApiGetActivitiesRequest, options?: AxiosRequestConfig): AxiosPromise<Activities> {
            return localVarFp.getActivities(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a user who is followed by the authenticated user. (use /users/{user_id} instead, to fetch the user details)
         * @param {MeApiGetFollowedUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getFollowedUser(requestParameters: MeApiGetFollowedUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getFollowedUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of users who are followed by the authenticated user.
         * @param {MeApiGetFollowedUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowedUsers(requestParameters: MeApiGetFollowedUsersRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Users> {
            return localVarFp.getFollowedUsers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a user who is following the authenticated user. (use /users/{user_id} instead, to fetch the user details)
         * @param {MeApiGetFollowerByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getFollowerById(requestParameters: MeApiGetFollowerByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getFollowerById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of users who are following the authenticated user.
         * @param {MeApiGetFollowersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowersList(requestParameters: MeApiGetFollowersListRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Users> {
            return localVarFp.getFollowersList(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of favorited or liked playlists of the authenticated user.
         * @param {MeApiGetLikedPlaylistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikedPlaylists(requestParameters: MeApiGetLikedPlaylistsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<MeGetLikedPlaylistsResponse> {
            return localVarFp.getLikedPlaylists(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Recent the authenticated user\'s activities.
         * @param {MeApiGetRecentActivitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentActivities(requestParameters: MeApiGetRecentActivitiesRequest, options?: AxiosRequestConfig): AxiosPromise<Activities> {
            return localVarFp.getRecentActivities(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the authenticated user\'s recent track related activities.
         * @param {MeApiGetRecentTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTracks(requestParameters: MeApiGetRecentTracksRequest, options?: AxiosRequestConfig): AxiosPromise<Activities> {
            return localVarFp.getRecentTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the authenticated userâ€™s information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInformation(options?: AxiosRequestConfig): AxiosPromise<Me> {
            return localVarFp.getUserInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of recent tracks from users followed by the authenticated user.
         * @param {MeApiListFollowedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFollowedTracks(requestParameters: MeApiListFollowedTracksRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Track>> {
            return localVarFp.listFollowedTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of favorited or liked tracks of the authenticated user.
         * @param {MeApiListLikedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikedTracks(requestParameters: MeApiListLikedTracksRequest = {}, options?: AxiosRequestConfig): AxiosPromise<MeListLikedTracksResponse> {
            return localVarFp.listLikedTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns playlist info, playlist tracks and tracks owner info.
         * @summary Returns userâ€™s playlists (sets).
         * @param {MeApiListPlaylistsInfoTracksOwnerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaylistsInfoTracksOwner(requestParameters: MeApiListPlaylistsInfoTracksOwnerRequest = {}, options?: AxiosRequestConfig): AxiosPromise<MeGetLikedPlaylistsResponse> {
            return localVarFp.listPlaylistsInfoTracksOwner(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of user\'s tracks.
         * @param {MeApiListUserTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserTracks(requestParameters: MeApiListUserTracksRequest = {}, options?: AxiosRequestConfig): AxiosPromise<MeListLikedTracksResponse> {
            return localVarFp.listUserTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteFollowedUser operation in MeApi.
 * @export
 * @interface MeApiDeleteFollowedUserRequest
 */
export type MeApiDeleteFollowedUserRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof MeApiDeleteFollowedUser
    */
    readonly userId: number
    
}

/**
 * Request parameters for followUser operation in MeApi.
 * @export
 * @interface MeApiFollowUserRequest
 */
export type MeApiFollowUserRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof MeApiFollowUser
    */
    readonly userId: number
    
}

/**
 * Request parameters for getActivities operation in MeApi.
 * @export
 * @interface MeApiGetActivitiesRequest
 */
export type MeApiGetActivitiesRequest = {
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof MeApiGetActivities
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiGetActivities
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getFollowedUser operation in MeApi.
 * @export
 * @interface MeApiGetFollowedUserRequest
 */
export type MeApiGetFollowedUserRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof MeApiGetFollowedUser
    */
    readonly userId: number
    
}

/**
 * Request parameters for getFollowedUsers operation in MeApi.
 * @export
 * @interface MeApiGetFollowedUsersRequest
 */
export type MeApiGetFollowedUsersRequest = {
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiGetFollowedUsers
    */
    readonly limit?: number
    
    /**
    * Offset of first result. Deprecated, use `linked_partitioning` instead.
    * @type {number}
    * @memberof MeApiGetFollowedUsers
    */
    readonly offset?: number
    
}

/**
 * Request parameters for getFollowerById operation in MeApi.
 * @export
 * @interface MeApiGetFollowerByIdRequest
 */
export type MeApiGetFollowerByIdRequest = {
    
    /**
    * SoundCloud User id to denote a Follower
    * @type {number}
    * @memberof MeApiGetFollowerById
    */
    readonly followerId: number
    
}

/**
 * Request parameters for getFollowersList operation in MeApi.
 * @export
 * @interface MeApiGetFollowersListRequest
 */
export type MeApiGetFollowersListRequest = {
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiGetFollowersList
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getLikedPlaylists operation in MeApi.
 * @export
 * @interface MeApiGetLikedPlaylistsRequest
 */
export type MeApiGetLikedPlaylistsRequest = {
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiGetLikedPlaylists
    */
    readonly limit?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof MeApiGetLikedPlaylists
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for getRecentActivities operation in MeApi.
 * @export
 * @interface MeApiGetRecentActivitiesRequest
 */
export type MeApiGetRecentActivitiesRequest = {
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof MeApiGetRecentActivities
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiGetRecentActivities
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getRecentTracks operation in MeApi.
 * @export
 * @interface MeApiGetRecentTracksRequest
 */
export type MeApiGetRecentTracksRequest = {
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof MeApiGetRecentTracks
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiGetRecentTracks
    */
    readonly limit?: number
    
}

/**
 * Request parameters for listFollowedTracks operation in MeApi.
 * @export
 * @interface MeApiListFollowedTracksRequest
 */
export type MeApiListFollowedTracksRequest = {
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof MeApiListFollowedTracks
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiListFollowedTracks
    */
    readonly limit?: number
    
    /**
    * Offset of first result. Deprecated, use `linked_partitioning` instead.
    * @type {number}
    * @memberof MeApiListFollowedTracks
    */
    readonly offset?: number
    
}

/**
 * Request parameters for listLikedTracks operation in MeApi.
 * @export
 * @interface MeApiListLikedTracksRequest
 */
export type MeApiListLikedTracksRequest = {
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiListLikedTracks
    */
    readonly limit?: number
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof MeApiListLikedTracks
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof MeApiListLikedTracks
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for listPlaylistsInfoTracksOwner operation in MeApi.
 * @export
 * @interface MeApiListPlaylistsInfoTracksOwnerRequest
 */
export type MeApiListPlaylistsInfoTracksOwnerRequest = {
    
    /**
    * A boolean flag to request a playlist with or without tracks. Default is `true`.
    * @type {boolean}
    * @memberof MeApiListPlaylistsInfoTracksOwner
    */
    readonly showTracks?: boolean
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof MeApiListPlaylistsInfoTracksOwner
    */
    readonly linkedPartitioning?: boolean
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiListPlaylistsInfoTracksOwner
    */
    readonly limit?: number
    
}

/**
 * Request parameters for listUserTracks operation in MeApi.
 * @export
 * @interface MeApiListUserTracksRequest
 */
export type MeApiListUserTracksRequest = {
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof MeApiListUserTracks
    */
    readonly limit?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof MeApiListUserTracks
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * MeApiGenerated - object-oriented interface
 * @export
 * @class MeApiGenerated
 * @extends {BaseAPI}
 */
export class MeApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Deletes a user who is followed by the authenticated user.
     * @param {MeApiDeleteFollowedUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public deleteFollowedUser(requestParameters: MeApiDeleteFollowedUserRequest, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).deleteFollowedUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Follows a user.
     * @param {MeApiFollowUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public followUser(requestParameters: MeApiFollowUserRequest, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).followUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the authenticated user\'s activities.
     * @param {MeApiGetActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getActivities(requestParameters: MeApiGetActivitiesRequest, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getActivities(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a user who is followed by the authenticated user. (use /users/{user_id} instead, to fetch the user details)
     * @param {MeApiGetFollowedUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getFollowedUser(requestParameters: MeApiGetFollowedUserRequest, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getFollowedUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of users who are followed by the authenticated user.
     * @param {MeApiGetFollowedUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getFollowedUsers(requestParameters: MeApiGetFollowedUsersRequest = {}, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getFollowedUsers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a user who is following the authenticated user. (use /users/{user_id} instead, to fetch the user details)
     * @param {MeApiGetFollowerByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getFollowerById(requestParameters: MeApiGetFollowerByIdRequest, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getFollowerById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of users who are following the authenticated user.
     * @param {MeApiGetFollowersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getFollowersList(requestParameters: MeApiGetFollowersListRequest = {}, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getFollowersList(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of favorited or liked playlists of the authenticated user.
     * @param {MeApiGetLikedPlaylistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getLikedPlaylists(requestParameters: MeApiGetLikedPlaylistsRequest = {}, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getLikedPlaylists(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Recent the authenticated user\'s activities.
     * @param {MeApiGetRecentActivitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getRecentActivities(requestParameters: MeApiGetRecentActivitiesRequest, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getRecentActivities(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the authenticated user\'s recent track related activities.
     * @param {MeApiGetRecentTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getRecentTracks(requestParameters: MeApiGetRecentTracksRequest, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getRecentTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the authenticated userâ€™s information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public getUserInformation(options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).getUserInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of recent tracks from users followed by the authenticated user.
     * @param {MeApiListFollowedTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public listFollowedTracks(requestParameters: MeApiListFollowedTracksRequest, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).listFollowedTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of favorited or liked tracks of the authenticated user.
     * @param {MeApiListLikedTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public listLikedTracks(requestParameters: MeApiListLikedTracksRequest = {}, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).listLikedTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns playlist info, playlist tracks and tracks owner info.
     * @summary Returns userâ€™s playlists (sets).
     * @param {MeApiListPlaylistsInfoTracksOwnerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public listPlaylistsInfoTracksOwner(requestParameters: MeApiListPlaylistsInfoTracksOwnerRequest = {}, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).listPlaylistsInfoTracksOwner(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of user\'s tracks.
     * @param {MeApiListUserTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApiGenerated
     */
    public listUserTracks(requestParameters: MeApiListUserTracksRequest = {}, options?: AxiosRequestConfig) {
        return MeApiFp(this.configuration).listUserTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
