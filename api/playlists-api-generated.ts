/* tslint:disable */
/* eslint-disable */
/*
SoundCloud Public API Specification

Discover and play over 320 million music tracks. Join the worldâ€™s largest online community of artists, bands, DJs, and audio creators.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { CreateUpdatePlaylistRequest } from '../models';
// @ts-ignore
import { CreateUpdatePlaylistRequestPlaylist } from '../models';
// @ts-ignore
import { MeListLikedTracksResponse } from '../models';
// @ts-ignore
import { Playlist } from '../models';
// @ts-ignore
import { PlaylistsCreateNewPlaylistRequest } from '../models';
// @ts-ignore
import { Users } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a playlist.
         * @param {CreateUpdatePlaylistRequest} [createUpdatePlaylistRequest] Create Playlist request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewPlaylist: async (createUpdatePlaylistRequest?: CreateUpdatePlaylistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/playlists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: createUpdatePlaylistRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/playlists',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a playlist.
         * @param {number} playlistId SoundCloud playlist id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist: async (playlistId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            assertParamExists('deletePlaylist', 'playlistId', playlistId)
            const localVarPath = `/playlists/{playlist_id}`
                .replace(`{${"playlist_id"}}`, encodeURIComponent(String(playlistId !== undefined ? playlistId : `-playlist_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/playlists/{playlist_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a playlist.
         * @param {number} playlistId SoundCloud playlist id
         * @param {string} [secretToken] A secret token to fetch private playlists/tracks
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {boolean} [showTracks] A boolean flag to request a playlist with or without tracks. Default is &#x60;true&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistById: async (playlistId: number, secretToken?: string, access?: Array<'playable' | 'preview' | 'blocked'>, showTracks?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            assertParamExists('getPlaylistById', 'playlistId', playlistId)
            const localVarPath = `/playlists/{playlist_id}`
                .replace(`{${"playlist_id"}}`, encodeURIComponent(String(playlistId !== undefined ? playlistId : `-playlist_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (secretToken !== undefined) {
                localVarQueryParameter['secret_token'] = secretToken;
            }

            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (showTracks !== undefined) {
                localVarQueryParameter['show_tracks'] = showTracks;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/playlists/{playlist_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns tracks under a playlist.
         * @param {number} playlistId SoundCloud playlist id
         * @param {string} [secretToken] A secret token to fetch private playlists/tracks
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracks: async (playlistId: number, secretToken?: string, access?: Array<'playable' | 'preview' | 'blocked'>, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            assertParamExists('getTracks', 'playlistId', playlistId)
            const localVarPath = `/playlists/{playlist_id}/tracks`
                .replace(`{${"playlist_id"}}`, encodeURIComponent(String(playlistId !== undefined ? playlistId : `-playlist_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (secretToken !== undefined) {
                localVarQueryParameter['secret_token'] = secretToken;
            }

            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/playlists/{playlist_id}/tracks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a collection of playlist\'s reposters.
         * @param {number} playlistId SoundCloud playlist id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReposters: async (playlistId: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            assertParamExists('listReposters', 'playlistId', playlistId)
            const localVarPath = `/playlists/{playlist_id}/reposters`
                .replace(`{${"playlist_id"}}`, encodeURIComponent(String(playlistId !== undefined ? playlistId : `-playlist_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/playlists/{playlist_id}/reposters',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a playlist.
         * @param {number} playlistId SoundCloud playlist id
         * @param {CreateUpdatePlaylistRequest} [createUpdatePlaylistRequest] Playlist payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylistById: async (playlistId: number, createUpdatePlaylistRequest?: CreateUpdatePlaylistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistId' is not null or undefined
            assertParamExists('updatePlaylistById', 'playlistId', playlistId)
            const localVarPath = `/playlists/{playlist_id}`
                .replace(`{${"playlist_id"}}`, encodeURIComponent(String(playlistId !== undefined ? playlistId : `-playlist_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: createUpdatePlaylistRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/playlists/{playlist_id}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(createUpdatePlaylistRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a playlist.
         * @param {PlaylistsApiCreateNewPlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewPlaylist(requestParameters: PlaylistsApiCreateNewPlaylistRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Playlist>> {
            const createUpdatePlaylistRequest: CreateUpdatePlaylistRequest = {
                playlist: requestParameters.playlist
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewPlaylist(createUpdatePlaylistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a playlist.
         * @param {PlaylistsApiDeletePlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaylist(requestParameters: PlaylistsApiDeletePlaylistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaylist(requestParameters.playlistId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a playlist.
         * @param {PlaylistsApiGetPlaylistByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaylistById(requestParameters: PlaylistsApiGetPlaylistByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Playlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaylistById(requestParameters.playlistId, requestParameters.secretToken, requestParameters.access, requestParameters.showTracks, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns tracks under a playlist.
         * @param {PlaylistsApiGetTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTracks(requestParameters: PlaylistsApiGetTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeListLikedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTracks(requestParameters.playlistId, requestParameters.secretToken, requestParameters.access, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a collection of playlist\'s reposters.
         * @param {PlaylistsApiListRepostersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReposters(requestParameters: PlaylistsApiListRepostersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReposters(requestParameters.playlistId, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a playlist.
         * @param {PlaylistsApiUpdatePlaylistByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaylistById(requestParameters: PlaylistsApiUpdatePlaylistByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Playlist>> {
            const createUpdatePlaylistRequest: CreateUpdatePlaylistRequest = {
                playlist: requestParameters.playlist
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaylistById(requestParameters.playlistId, createUpdatePlaylistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistsApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a playlist.
         * @param {PlaylistsApiCreateNewPlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewPlaylist(requestParameters: PlaylistsApiCreateNewPlaylistRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Playlist> {
            return localVarFp.createNewPlaylist(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a playlist.
         * @param {PlaylistsApiDeletePlaylistRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaylist(requestParameters: PlaylistsApiDeletePlaylistRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePlaylist(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a playlist.
         * @param {PlaylistsApiGetPlaylistByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaylistById(requestParameters: PlaylistsApiGetPlaylistByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Playlist> {
            return localVarFp.getPlaylistById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns tracks under a playlist.
         * @param {PlaylistsApiGetTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTracks(requestParameters: PlaylistsApiGetTracksRequest, options?: AxiosRequestConfig): AxiosPromise<MeListLikedTracksResponse> {
            return localVarFp.getTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a collection of playlist\'s reposters.
         * @param {PlaylistsApiListRepostersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReposters(requestParameters: PlaylistsApiListRepostersRequest, options?: AxiosRequestConfig): AxiosPromise<Users> {
            return localVarFp.listReposters(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a playlist.
         * @param {PlaylistsApiUpdatePlaylistByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaylistById(requestParameters: PlaylistsApiUpdatePlaylistByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Playlist> {
            return localVarFp.updatePlaylistById(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNewPlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiCreateNewPlaylistRequest
 */
export type PlaylistsApiCreateNewPlaylistRequest = {
    
} & CreateUpdatePlaylistRequest

/**
 * Request parameters for deletePlaylist operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiDeletePlaylistRequest
 */
export type PlaylistsApiDeletePlaylistRequest = {
    
    /**
    * SoundCloud playlist id
    * @type {number}
    * @memberof PlaylistsApiDeletePlaylist
    */
    readonly playlistId: number
    
}

/**
 * Request parameters for getPlaylistById operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetPlaylistByIdRequest
 */
export type PlaylistsApiGetPlaylistByIdRequest = {
    
    /**
    * SoundCloud playlist id
    * @type {number}
    * @memberof PlaylistsApiGetPlaylistById
    */
    readonly playlistId: number
    
    /**
    * A secret token to fetch private playlists/tracks
    * @type {string}
    * @memberof PlaylistsApiGetPlaylistById
    */
    readonly secretToken?: string
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof PlaylistsApiGetPlaylistById
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * A boolean flag to request a playlist with or without tracks. Default is `true`.
    * @type {boolean}
    * @memberof PlaylistsApiGetPlaylistById
    */
    readonly showTracks?: boolean
    
}

/**
 * Request parameters for getTracks operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiGetTracksRequest
 */
export type PlaylistsApiGetTracksRequest = {
    
    /**
    * SoundCloud playlist id
    * @type {number}
    * @memberof PlaylistsApiGetTracks
    */
    readonly playlistId: number
    
    /**
    * A secret token to fetch private playlists/tracks
    * @type {string}
    * @memberof PlaylistsApiGetTracks
    */
    readonly secretToken?: string
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof PlaylistsApiGetTracks
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof PlaylistsApiGetTracks
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for listReposters operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiListRepostersRequest
 */
export type PlaylistsApiListRepostersRequest = {
    
    /**
    * SoundCloud playlist id
    * @type {number}
    * @memberof PlaylistsApiListReposters
    */
    readonly playlistId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof PlaylistsApiListReposters
    */
    readonly limit?: number
    
}

/**
 * Request parameters for updatePlaylistById operation in PlaylistsApi.
 * @export
 * @interface PlaylistsApiUpdatePlaylistByIdRequest
 */
export type PlaylistsApiUpdatePlaylistByIdRequest = {
    
    /**
    * SoundCloud playlist id
    * @type {number}
    * @memberof PlaylistsApiUpdatePlaylistById
    */
    readonly playlistId: number
    
} & CreateUpdatePlaylistRequest

/**
 * PlaylistsApiGenerated - object-oriented interface
 * @export
 * @class PlaylistsApiGenerated
 * @extends {BaseAPI}
 */
export class PlaylistsApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Creates a playlist.
     * @param {PlaylistsApiCreateNewPlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApiGenerated
     */
    public createNewPlaylist(requestParameters: PlaylistsApiCreateNewPlaylistRequest = {}, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).createNewPlaylist(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a playlist.
     * @param {PlaylistsApiDeletePlaylistRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApiGenerated
     */
    public deletePlaylist(requestParameters: PlaylistsApiDeletePlaylistRequest, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).deletePlaylist(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a playlist.
     * @param {PlaylistsApiGetPlaylistByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApiGenerated
     */
    public getPlaylistById(requestParameters: PlaylistsApiGetPlaylistByIdRequest, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getPlaylistById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns tracks under a playlist.
     * @param {PlaylistsApiGetTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApiGenerated
     */
    public getTracks(requestParameters: PlaylistsApiGetTracksRequest, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).getTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a collection of playlist\'s reposters.
     * @param {PlaylistsApiListRepostersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApiGenerated
     */
    public listReposters(requestParameters: PlaylistsApiListRepostersRequest, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).listReposters(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a playlist.
     * @param {PlaylistsApiUpdatePlaylistByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApiGenerated
     */
    public updatePlaylistById(requestParameters: PlaylistsApiUpdatePlaylistByIdRequest, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).updatePlaylistById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
