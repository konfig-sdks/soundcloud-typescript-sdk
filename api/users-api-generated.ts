/* tslint:disable */
/* eslint-disable */
/*
SoundCloud Public API Specification

Discover and play over 320 million music tracks. Join the world’s largest online community of artists, bands, DJs, and audio creators.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { MeGetLikedPlaylistsResponse } from '../models';
// @ts-ignore
import { MeListLikedTracksResponse } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { Users } from '../models';
// @ts-ignore
import { WebProfilesInner } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of users that follows (user_id).
         * @summary Returns a list of user’s followers.
         * @param {number} userId SoundCloud User id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers: async (userId: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFollowers', 'userId', userId)
            const localVarPath = `/users/{user_id}/followers`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/followers',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns (following_id) that is followed by (user_id).
         * @summary Returns a user\'s following. (use /users/{user_id} instead, to fetch the user details)
         * @param {number} userId SoundCloud User id
         * @param {number} followingId SoundCloud User id to denote a Following of a user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getFollowingById: async (userId: number, followingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFollowingById', 'userId', userId)
            // verify required parameter 'followingId' is not null or undefined
            assertParamExists('getFollowingById', 'followingId', followingId)
            const localVarPath = `/users/{user_id}/followings/{following_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)))
                .replace(`{${"following_id"}}`, encodeURIComponent(String(followingId !== undefined ? followingId : `-following_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/followings/{following_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a user.
         * @param {number} userId SoundCloud User id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUser', 'userId', userId)
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of users that (user_id) follows.
         * @summary Returns a list of user’s followings.
         * @param {number} userId SoundCloud User id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowings: async (userId: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserFollowings', 'userId', userId)
            const localVarPath = `/users/{user_id}/followings`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/followings',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of user\'s playlists.
         * @param {number} userId SoundCloud User id
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {boolean} [showTracks] A boolean flag to request a playlist with or without tracks. Default is &#x60;true&#x60;.
         * @param {number} [limit] Number of results to return in the collection.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPlaylists: async (userId: number, access?: Array<'playable' | 'preview' | 'blocked'>, showTracks?: boolean, limit?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserPlaylists', 'userId', userId)
            const localVarPath = `/users/{user_id}/playlists`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (showTracks !== undefined) {
                localVarQueryParameter['show_tracks'] = showTracks;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/playlists',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of user\'s tracks.
         * @param {number} userId SoundCloud User id
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {number} [limit] Number of results to return in the collection.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTracks: async (userId: number, access?: Array<'playable' | 'preview' | 'blocked'>, limit?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserTracks', 'userId', userId)
            const localVarPath = `/users/{user_id}/tracks`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/tracks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns list of user\'s links added to their profile (website, facebook, instagram).
         * @param {number} userId SoundCloud User id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWebProfiles: async (userId: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserWebProfiles', 'userId', userId)
            const localVarPath = `/users/{user_id}/web-profiles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/web-profiles',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of user\'s favorited or liked tracks. (use /users/:userId/likes/tracks instead, to fetch a user\'s likes)
         * @param {number} userId SoundCloud User id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listFavorites: async (userId: number, limit?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listFavorites', 'userId', userId)
            const localVarPath = `/users/{user_id}/favorites`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/favorites',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of user\'s liked playlists.
         * @param {number} userId SoundCloud User id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikedPlaylists: async (userId: number, limit?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listLikedPlaylists', 'userId', userId)
            const localVarPath = `/users/{user_id}/likes/playlists`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/likes/playlists',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of user\'s liked tracks.
         * @param {number} userId SoundCloud User id
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {number} [limit] Number of results to return in the collection.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikedTracks: async (userId: number, access?: Array<'playable' | 'preview' | 'blocked'>, limit?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listLikedTracks', 'userId', userId)
            const localVarPath = `/users/{user_id}/likes/tracks`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId !== undefined ? userId : `-user_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/users/{user_id}/likes/tracks',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of users that follows (user_id).
         * @summary Returns a list of user’s followers.
         * @param {UsersApiGetFollowersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowers(requestParameters: UsersApiGetFollowersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowers(requestParameters.userId, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns (following_id) that is followed by (user_id).
         * @summary Returns a user\'s following. (use /users/{user_id} instead, to fetch the user details)
         * @param {UsersApiGetFollowingByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getFollowingById(requestParameters: UsersApiGetFollowingByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowingById(requestParameters.userId, requestParameters.followingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a user.
         * @param {UsersApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(requestParameters: UsersApiGetUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(requestParameters.userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns list of users that (user_id) follows.
         * @summary Returns a list of user’s followings.
         * @param {UsersApiGetUserFollowingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserFollowings(requestParameters: UsersApiGetUserFollowingsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserFollowings(requestParameters.userId, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of user\'s playlists.
         * @param {UsersApiGetUserPlaylistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPlaylists(requestParameters: UsersApiGetUserPlaylistsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeGetLikedPlaylistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPlaylists(requestParameters.userId, requestParameters.access, requestParameters.showTracks, requestParameters.limit, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of user\'s tracks.
         * @param {UsersApiGetUserTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTracks(requestParameters: UsersApiGetUserTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeListLikedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTracks(requestParameters.userId, requestParameters.access, requestParameters.limit, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns list of user\'s links added to their profile (website, facebook, instagram).
         * @param {UsersApiGetUserWebProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWebProfiles(requestParameters: UsersApiGetUserWebProfilesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebProfilesInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWebProfiles(requestParameters.userId, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of user\'s favorited or liked tracks. (use /users/:userId/likes/tracks instead, to fetch a user\'s likes)
         * @param {UsersApiListFavoritesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async listFavorites(requestParameters: UsersApiListFavoritesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeListLikedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFavorites(requestParameters.userId, requestParameters.limit, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of user\'s liked playlists.
         * @param {UsersApiListLikedPlaylistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLikedPlaylists(requestParameters: UsersApiListLikedPlaylistsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeGetLikedPlaylistsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLikedPlaylists(requestParameters.userId, requestParameters.limit, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of user\'s liked tracks.
         * @param {UsersApiListLikedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listLikedTracks(requestParameters: UsersApiListLikedTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeListLikedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listLikedTracks(requestParameters.userId, requestParameters.access, requestParameters.limit, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Returns a list of users that follows (user_id).
         * @summary Returns a list of user’s followers.
         * @param {UsersApiGetFollowersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers(requestParameters: UsersApiGetFollowersRequest, options?: AxiosRequestConfig): AxiosPromise<Users> {
            return localVarFp.getFollowers(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns (following_id) that is followed by (user_id).
         * @summary Returns a user\'s following. (use /users/{user_id} instead, to fetch the user details)
         * @param {UsersApiGetFollowingByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getFollowingById(requestParameters: UsersApiGetFollowingByIdRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getFollowingById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a user.
         * @param {UsersApiGetUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(requestParameters: UsersApiGetUserRequest, options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUser(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of users that (user_id) follows.
         * @summary Returns a list of user’s followings.
         * @param {UsersApiGetUserFollowingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserFollowings(requestParameters: UsersApiGetUserFollowingsRequest, options?: AxiosRequestConfig): AxiosPromise<Users> {
            return localVarFp.getUserFollowings(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of user\'s playlists.
         * @param {UsersApiGetUserPlaylistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPlaylists(requestParameters: UsersApiGetUserPlaylistsRequest, options?: AxiosRequestConfig): AxiosPromise<MeGetLikedPlaylistsResponse> {
            return localVarFp.getUserPlaylists(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of user\'s tracks.
         * @param {UsersApiGetUserTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTracks(requestParameters: UsersApiGetUserTracksRequest, options?: AxiosRequestConfig): AxiosPromise<MeListLikedTracksResponse> {
            return localVarFp.getUserTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns list of user\'s links added to their profile (website, facebook, instagram).
         * @param {UsersApiGetUserWebProfilesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWebProfiles(requestParameters: UsersApiGetUserWebProfilesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<WebProfilesInner>> {
            return localVarFp.getUserWebProfiles(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of user\'s favorited or liked tracks. (use /users/:userId/likes/tracks instead, to fetch a user\'s likes)
         * @param {UsersApiListFavoritesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        listFavorites(requestParameters: UsersApiListFavoritesRequest, options?: AxiosRequestConfig): AxiosPromise<MeListLikedTracksResponse> {
            return localVarFp.listFavorites(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of user\'s liked playlists.
         * @param {UsersApiListLikedPlaylistsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikedPlaylists(requestParameters: UsersApiListLikedPlaylistsRequest, options?: AxiosRequestConfig): AxiosPromise<MeGetLikedPlaylistsResponse> {
            return localVarFp.listLikedPlaylists(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of user\'s liked tracks.
         * @param {UsersApiListLikedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listLikedTracks(requestParameters: UsersApiListLikedTracksRequest, options?: AxiosRequestConfig): AxiosPromise<MeListLikedTracksResponse> {
            return localVarFp.listLikedTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getFollowers operation in UsersApi.
 * @export
 * @interface UsersApiGetFollowersRequest
 */
export type UsersApiGetFollowersRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiGetFollowers
    */
    readonly userId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof UsersApiGetFollowers
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getFollowingById operation in UsersApi.
 * @export
 * @interface UsersApiGetFollowingByIdRequest
 */
export type UsersApiGetFollowingByIdRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiGetFollowingById
    */
    readonly userId: number
    
    /**
    * SoundCloud User id to denote a Following of a user
    * @type {number}
    * @memberof UsersApiGetFollowingById
    */
    readonly followingId: number
    
}

/**
 * Request parameters for getUser operation in UsersApi.
 * @export
 * @interface UsersApiGetUserRequest
 */
export type UsersApiGetUserRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiGetUser
    */
    readonly userId: number
    
}

/**
 * Request parameters for getUserFollowings operation in UsersApi.
 * @export
 * @interface UsersApiGetUserFollowingsRequest
 */
export type UsersApiGetUserFollowingsRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiGetUserFollowings
    */
    readonly userId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof UsersApiGetUserFollowings
    */
    readonly limit?: number
    
}

/**
 * Request parameters for getUserPlaylists operation in UsersApi.
 * @export
 * @interface UsersApiGetUserPlaylistsRequest
 */
export type UsersApiGetUserPlaylistsRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiGetUserPlaylists
    */
    readonly userId: number
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof UsersApiGetUserPlaylists
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * A boolean flag to request a playlist with or without tracks. Default is `true`.
    * @type {boolean}
    * @memberof UsersApiGetUserPlaylists
    */
    readonly showTracks?: boolean
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof UsersApiGetUserPlaylists
    */
    readonly limit?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof UsersApiGetUserPlaylists
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for getUserTracks operation in UsersApi.
 * @export
 * @interface UsersApiGetUserTracksRequest
 */
export type UsersApiGetUserTracksRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiGetUserTracks
    */
    readonly userId: number
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof UsersApiGetUserTracks
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof UsersApiGetUserTracks
    */
    readonly limit?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof UsersApiGetUserTracks
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for getUserWebProfiles operation in UsersApi.
 * @export
 * @interface UsersApiGetUserWebProfilesRequest
 */
export type UsersApiGetUserWebProfilesRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiGetUserWebProfiles
    */
    readonly userId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof UsersApiGetUserWebProfiles
    */
    readonly limit?: number
    
}

/**
 * Request parameters for listFavorites operation in UsersApi.
 * @export
 * @interface UsersApiListFavoritesRequest
 */
export type UsersApiListFavoritesRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiListFavorites
    */
    readonly userId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof UsersApiListFavorites
    */
    readonly limit?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof UsersApiListFavorites
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for listLikedPlaylists operation in UsersApi.
 * @export
 * @interface UsersApiListLikedPlaylistsRequest
 */
export type UsersApiListLikedPlaylistsRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiListLikedPlaylists
    */
    readonly userId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof UsersApiListLikedPlaylists
    */
    readonly limit?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof UsersApiListLikedPlaylists
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for listLikedTracks operation in UsersApi.
 * @export
 * @interface UsersApiListLikedTracksRequest
 */
export type UsersApiListLikedTracksRequest = {
    
    /**
    * SoundCloud User id
    * @type {number}
    * @memberof UsersApiListLikedTracks
    */
    readonly userId: number
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof UsersApiListLikedTracks
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof UsersApiListLikedTracks
    */
    readonly limit?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof UsersApiListLikedTracks
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * UsersApiGenerated - object-oriented interface
 * @export
 * @class UsersApiGenerated
 * @extends {BaseAPI}
 */
export class UsersApiGenerated extends BaseAPI {
    /**
     * Returns a list of users that follows (user_id).
     * @summary Returns a list of user’s followers.
     * @param {UsersApiGetFollowersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getFollowers(requestParameters: UsersApiGetFollowersRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowers(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns (following_id) that is followed by (user_id).
     * @summary Returns a user\'s following. (use /users/{user_id} instead, to fetch the user details)
     * @param {UsersApiGetFollowingByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getFollowingById(requestParameters: UsersApiGetFollowingByIdRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getFollowingById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a user.
     * @param {UsersApiGetUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUser(requestParameters: UsersApiGetUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUser(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns list of users that (user_id) follows.
     * @summary Returns a list of user’s followings.
     * @param {UsersApiGetUserFollowingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUserFollowings(requestParameters: UsersApiGetUserFollowingsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserFollowings(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of user\'s playlists.
     * @param {UsersApiGetUserPlaylistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUserPlaylists(requestParameters: UsersApiGetUserPlaylistsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserPlaylists(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of user\'s tracks.
     * @param {UsersApiGetUserTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUserTracks(requestParameters: UsersApiGetUserTracksRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns list of user\'s links added to their profile (website, facebook, instagram).
     * @param {UsersApiGetUserWebProfilesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public getUserWebProfiles(requestParameters: UsersApiGetUserWebProfilesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).getUserWebProfiles(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of user\'s favorited or liked tracks. (use /users/:userId/likes/tracks instead, to fetch a user\'s likes)
     * @param {UsersApiListFavoritesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listFavorites(requestParameters: UsersApiListFavoritesRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listFavorites(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of user\'s liked playlists.
     * @param {UsersApiListLikedPlaylistsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listLikedPlaylists(requestParameters: UsersApiListLikedPlaylistsRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listLikedPlaylists(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of user\'s liked tracks.
     * @param {UsersApiListLikedTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApiGenerated
     */
    public listLikedTracks(requestParameters: UsersApiListLikedTracksRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listLikedTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
