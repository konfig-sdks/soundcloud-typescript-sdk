/* tslint:disable */
/* eslint-disable */
/*
SoundCloud Public API Specification

Discover and play over 320 million music tracks. Join the world’s largest online community of artists, bands, DJs, and audio creators.

The version of the OpenAPI document: 1.0.0


NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { fromBuffer } from "file-type/browser"
const FormData = require("form-data")
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Comment } from '../models';
// @ts-ignore
import { Comments } from '../models';
// @ts-ignore
import { MeListLikedTracksResponse } from '../models';
// @ts-ignore
import { Streams } from '../models';
// @ts-ignore
import { TooManyRequests } from '../models';
// @ts-ignore
import { Track } from '../models';
// @ts-ignore
import { TrackDataRequest } from '../models';
// @ts-ignore
import { TrackMetadataRequest } from '../models';
// @ts-ignore
import { TrackMetadataRequestTrack } from '../models';
// @ts-ignore
import { TracksCreateCommentRequest } from '../models';
// @ts-ignore
import { TracksCreateCommentRequestComment } from '../models';
// @ts-ignore
import { TracksUploadNewTrackRequest } from '../models';
// @ts-ignore
import { TracksUploadNewTrackRequest1 } from '../models';
// @ts-ignore
import { Users } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TracksApi - axios parameter creator
 * @export
 */
export const TracksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the newly created comment on success
         * @param {number} trackId SoundCloud Track id
         * @param {TracksCreateCommentRequest} tracksCreateCommentRequest Body of a comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment: async (trackId: number, tracksCreateCommentRequest: TracksCreateCommentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('createComment', 'trackId', trackId)
            // verify required parameter 'tracksCreateCommentRequest' is not null or undefined
            assertParamExists('createComment', 'tracksCreateCommentRequest', tracksCreateCommentRequest)
            const localVarPath = `/tracks/{track_id}/comments`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json; charset=utf-8';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: tracksCreateCommentRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}/comments',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(tracksCreateCommentRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a track.
         * @param {number} trackId SoundCloud Track id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrack: async (trackId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('deleteTrack', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a track.
         * @param {number} trackId SoundCloud Track id
         * @param {string} [secretToken] A secret token to fetch private playlists/tracks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (trackId: number, secretToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getById', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (secretToken !== undefined) {
                localVarQueryParameter['secret_token'] = secretToken;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the comments posted on the track(track_id).
         * @param {number} trackId SoundCloud Track id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {number} [offset] Offset of first result. Deprecated, use &#x60;linked_partitioning&#x60; instead.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (trackId: number, limit?: number, offset?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getComments', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/comments`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}/comments',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of users who have favorited or liked the track.
         * @param {number} trackId SoundCloud Track id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriters: async (trackId: number, limit?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getFavoriters', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/favoriters`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}/favoriters',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all related tracks of track on SoundCloud.
         * @param {number} trackId SoundCloud Track id
         * @param {Array<'playable' | 'preview' | 'blocked'>} [access] Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\&#39;d like to see all possible tracks. See &#x60;Track#access&#x60; schema for more details. 
         * @param {number} [limit] Number of results to return in the collection.
         * @param {number} [offset] Offset of first result. Deprecated, use &#x60;linked_partitioning&#x60; instead.
         * @param {boolean} [linkedPartitioning] Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedTracks: async (trackId: number, access?: Array<'playable' | 'preview' | 'blocked'>, limit?: number, offset?: number, linkedPartitioning?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getRelatedTracks', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/related`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (access) {
                localVarQueryParameter['access'] = access.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (linkedPartitioning !== undefined) {
                localVarQueryParameter['linked_partitioning'] = linkedPartitioning;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}/related',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a track\'s streamable URLs
         * @param {number} trackId SoundCloud Track id
         * @param {string} [secretToken] A secret token to fetch private playlists/tracks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamableUrls: async (trackId: number, secretToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('getStreamableUrls', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/streams`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (secretToken !== undefined) {
                localVarQueryParameter['secret_token'] = secretToken;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}/streams',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a collection of track\'s reposters.
         * @param {number} trackId SoundCloud Track id
         * @param {number} [limit] Number of results to return in the collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReposters: async (trackId: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('listReposters', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}/reposters`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}/reposters',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a track\'s information.
         * @param {number} trackId SoundCloud Track id
         * @param {TrackMetadataRequest} [trackMetadataRequest] Track payload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackInformation: async (trackId: number, trackMetadataRequest?: TrackMetadataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            assertParamExists('updateTrackInformation', 'trackId', trackId)
            const localVarPath = `/tracks/{track_id}`
                .replace(`{${"track_id"}}`, encodeURIComponent(String(trackId !== undefined ? trackId : `-track_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: trackMetadataRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks/{track_id}',
                httpMethod: 'PUT'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads a new track.
         * @param {string} [trackTitle] 
         * @param {Uint8Array | File | buffer.File} [trackAssetData] 
         * @param {string} [trackPermalink] 
         * @param {string} [trackSharing] 
         * @param {string} [trackEmbeddableBy] who can embed this track \\\&quot;all\\\&quot;, \\\&quot;me\\\&quot;, or \\\&quot;none\\\&quot;
         * @param {string} [trackPurchaseUrl] 
         * @param {string} [trackDescription] 
         * @param {string} [trackGenre] 
         * @param {string} [trackTagList] The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY&#x3D;VALUE. For example: geo:lat&#x3D;43.555 camel:size&#x3D;medium “machine:tag&#x3D;with space” Machine tags are not revealed to the user on the track pages.
         * @param {string} [trackLabelName] 
         * @param {string} [trackRelease] 
         * @param {string} [trackReleaseDate] string, formatted as yyyy-mm-dd, representing release date
         * @param {boolean} [trackStreamable] 
         * @param {boolean} [trackDownloadable] 
         * @param {string} [trackLicense] Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
         * @param {boolean} [trackCommentable] 
         * @param {string} [trackIsrc] 
         * @param {Uint8Array | File | buffer.File} [trackArtworkData] 
         * @param {TracksUploadNewTrackRequest} [tracksUploadNewTrackRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadNewTrack: async (trackTitle?: string, trackAssetData?: Uint8Array | File | buffer.File, trackPermalink?: string, trackSharing?: string, trackEmbeddableBy?: string, trackPurchaseUrl?: string, trackDescription?: string, trackGenre?: string, trackTagList?: string, trackLabelName?: string, trackRelease?: string, trackReleaseDate?: string, trackStreamable?: boolean, trackDownloadable?: boolean, trackLicense?: string, trackCommentable?: boolean, trackIsrc?: string, trackArtworkData?: Uint8Array | File | buffer.File, tracksUploadNewTrackRequest?: TracksUploadNewTrackRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tracks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            const addFormParam = async (name: string, data: any, isBinary: boolean, isPrimitiveType: boolean) => {
                if (isBinary) {
                    if (data instanceof Uint8Array) {
                        // Handle Buffer data
                        const filetype = await fromBuffer(data)
                        const filename = filetype === undefined ? name : `${name}.${filetype.ext}`
                        localVarFormParams.append(name, data as any, filename);
                    } else if ("name" in data) {
                        // File instances in browsers and Node.js have the
                        // "name" property "Duck typing" files to handle browser
                        // File class or Node.js File class
                        // Web: https://developer.mozilla.org/en-US/docs/Web/API/File
                        // Node.js: https://nodejs.org/api/buffer.html#new-bufferfilesources-filename-options
                        if (isBrowser()) {
                            // FormData in browser can accept File/Blob directly
                            localVarFormParams.append(name, data, data.name);
                        } else {
                            // FormData in Node.js can only accept raw Buffer so convert before passing
                            const bytes = await data.arrayBuffer()
                            const buffer = Buffer.from(bytes)
                            localVarFormParams.append(name, buffer, data.name);
                        }
                    }
                } else {
                    if (isPrimitiveType) {
                        /**
                         * FormData can only accept string or Blob so we need to convert
                         * non-string primitives to string. We also need to convert
                         */
                        if (typeof data === "object") {
                          localVarFormParams.append(name, JSON.stringify(data));
                        } else {
                          localVarFormParams.append(name, data);
                        }
                    } else {
                        if (isBrowser()) {
                            localVarFormParams.append(name, new Blob([JSON.stringify(data)], { type: "application/json" }))
                        } else {
                            localVarFormParams.append(name, JSON.stringify(data), { type: "application/json", filename: "data.json" });
                        }
                    }
                }
            }
            if (!isBrowser()) Object.assign(localVarHeaderParameter, localVarFormParams.getHeaders());

            // authentication AuthHeader required
            await setApiKeyToObject({ object: localVarHeaderParameter, key: "Authorization", keyParamName: "authHeader", configuration })

            if (trackTitle !== undefined) {
                await addFormParam('track[title]', trackTitle, false, true)
            }
    
            if (trackAssetData !== undefined) {
                await addFormParam('track[asset_data]', trackAssetData, true, true)
            }
    
            if (trackPermalink !== undefined) {
                await addFormParam('track[permalink]', trackPermalink, false, true)
            }
    
            if (trackSharing !== undefined) {
                await addFormParam('track[sharing]', trackSharing, false, true)
            }
    
            if (trackEmbeddableBy !== undefined) {
                await addFormParam('track[embeddable_by]', trackEmbeddableBy, false, true)
            }
    
            if (trackPurchaseUrl !== undefined) {
                await addFormParam('track[purchase_url]', trackPurchaseUrl, false, true)
            }
    
            if (trackDescription !== undefined) {
                await addFormParam('track[description]', trackDescription, false, true)
            }
    
            if (trackGenre !== undefined) {
                await addFormParam('track[genre]', trackGenre, false, true)
            }
    
            if (trackTagList !== undefined) {
                await addFormParam('track[tag_list]', trackTagList, false, true)
            }
    
            if (trackLabelName !== undefined) {
                await addFormParam('track[label_name]', trackLabelName, false, true)
            }
    
            if (trackRelease !== undefined) {
                await addFormParam('track[release]', trackRelease, false, true)
            }
    
            if (trackReleaseDate !== undefined) {
                await addFormParam('track[release_date]', trackReleaseDate, false, true)
            }
    
            if (trackStreamable !== undefined) {
                await addFormParam('track[streamable]', trackStreamable, false, true)
            }
    
            if (trackDownloadable !== undefined) {
                await addFormParam('track[downloadable]', trackDownloadable, false, true)
            }
    
            if (trackLicense !== undefined) {
                await addFormParam('track[license]', trackLicense, false, true)
            }
    
            if (trackCommentable !== undefined) {
                await addFormParam('track[commentable]', trackCommentable, false, true)
            }
    
            if (trackIsrc !== undefined) {
                await addFormParam('track[isrc]', trackIsrc, false, true)
            }
    
            if (trackArtworkData !== undefined) {
                await addFormParam('track[artwork_data]', trackArtworkData, true, true)
            }
    
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;
            requestBeforeHook({
                requestBody: tracksUploadNewTrackRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/tracks',
                httpMethod: 'POST'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TracksApi - functional programming interface
 * @export
 */
export const TracksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TracksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the newly created comment on success
         * @param {TracksApiCreateCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComment(requestParameters: TracksApiCreateCommentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const tracksCreateCommentRequest: TracksCreateCommentRequest = {
                comment: requestParameters.comment
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComment(requestParameters.trackId, tracksCreateCommentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a track.
         * @param {TracksApiDeleteTrackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTrack(requestParameters: TracksApiDeleteTrackRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTrack(requestParameters.trackId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a track.
         * @param {TracksApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(requestParameters: TracksApiGetByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Track>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(requestParameters.trackId, requestParameters.secretToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the comments posted on the track(track_id).
         * @param {TracksApiGetCommentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(requestParameters: TracksApiGetCommentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comments>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(requestParameters.trackId, requestParameters.limit, requestParameters.offset, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a list of users who have favorited or liked the track.
         * @param {TracksApiGetFavoritersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoriters(requestParameters: TracksApiGetFavoritersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoriters(requestParameters.trackId, requestParameters.limit, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all related tracks of track on SoundCloud.
         * @param {TracksApiGetRelatedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelatedTracks(requestParameters: TracksApiGetRelatedTracksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeListLikedTracksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelatedTracks(requestParameters.trackId, requestParameters.access, requestParameters.limit, requestParameters.offset, requestParameters.linkedPartitioning, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a track\'s streamable URLs
         * @param {TracksApiGetStreamableUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStreamableUrls(requestParameters: TracksApiGetStreamableUrlsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Streams>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStreamableUrls(requestParameters.trackId, requestParameters.secretToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a collection of track\'s reposters.
         * @param {TracksApiListRepostersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listReposters(requestParameters: TracksApiListRepostersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Users>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listReposters(requestParameters.trackId, requestParameters.limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a track\'s information.
         * @param {TracksApiUpdateTrackInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTrackInformation(requestParameters: TracksApiUpdateTrackInformationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Track>> {
            const trackMetadataRequest: TrackMetadataRequest = {
                track: requestParameters.track
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTrackInformation(requestParameters.trackId, trackMetadataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Uploads a new track.
         * @param {TracksApiUploadNewTrackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadNewTrack(requestParameters: TracksApiUploadNewTrackRequest = {}, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Track>> {
            const tracksUploadNewTrackRequest: TracksUploadNewTrackRequest = requestParameters;
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadNewTrack(requestParameters.trackTitle, requestParameters.trackAssetData, requestParameters.trackPermalink, requestParameters.trackSharing, requestParameters.trackEmbeddableBy, requestParameters.trackPurchaseUrl, requestParameters.trackDescription, requestParameters.trackGenre, requestParameters.trackTagList, requestParameters.trackLabelName, requestParameters.trackRelease, requestParameters.trackReleaseDate, requestParameters.trackStreamable, requestParameters.trackDownloadable, requestParameters.trackLicense, requestParameters.trackCommentable, requestParameters.trackIsrc, requestParameters.trackArtworkData, tracksUploadNewTrackRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TracksApi - factory interface
 * @export
 */
export const TracksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TracksApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the newly created comment on success
         * @param {TracksApiCreateCommentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(requestParameters: TracksApiCreateCommentRequest, options?: AxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.createComment(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a track.
         * @param {TracksApiDeleteTrackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrack(requestParameters: TracksApiDeleteTrackRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTrack(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a track.
         * @param {TracksApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: TracksApiGetByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Track> {
            return localVarFp.getById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the comments posted on the track(track_id).
         * @param {TracksApiGetCommentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(requestParameters: TracksApiGetCommentsRequest, options?: AxiosRequestConfig): AxiosPromise<Comments> {
            return localVarFp.getComments(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of users who have favorited or liked the track.
         * @param {TracksApiGetFavoritersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriters(requestParameters: TracksApiGetFavoritersRequest, options?: AxiosRequestConfig): AxiosPromise<Users> {
            return localVarFp.getFavoriters(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all related tracks of track on SoundCloud.
         * @param {TracksApiGetRelatedTracksRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelatedTracks(requestParameters: TracksApiGetRelatedTracksRequest, options?: AxiosRequestConfig): AxiosPromise<MeListLikedTracksResponse> {
            return localVarFp.getRelatedTracks(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a track\'s streamable URLs
         * @param {TracksApiGetStreamableUrlsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStreamableUrls(requestParameters: TracksApiGetStreamableUrlsRequest, options?: AxiosRequestConfig): AxiosPromise<Streams> {
            return localVarFp.getStreamableUrls(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a collection of track\'s reposters.
         * @param {TracksApiListRepostersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listReposters(requestParameters: TracksApiListRepostersRequest, options?: AxiosRequestConfig): AxiosPromise<Users> {
            return localVarFp.listReposters(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a track\'s information.
         * @param {TracksApiUpdateTrackInformationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTrackInformation(requestParameters: TracksApiUpdateTrackInformationRequest, options?: AxiosRequestConfig): AxiosPromise<Track> {
            return localVarFp.updateTrackInformation(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Uploads a new track.
         * @param {TracksApiUploadNewTrackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadNewTrack(requestParameters: TracksApiUploadNewTrackRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Track> {
            return localVarFp.uploadNewTrack(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createComment operation in TracksApi.
 * @export
 * @interface TracksApiCreateCommentRequest
 */
export type TracksApiCreateCommentRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiCreateComment
    */
    readonly trackId: number
    
} & TracksCreateCommentRequest

/**
 * Request parameters for deleteTrack operation in TracksApi.
 * @export
 * @interface TracksApiDeleteTrackRequest
 */
export type TracksApiDeleteTrackRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiDeleteTrack
    */
    readonly trackId: number
    
}

/**
 * Request parameters for getById operation in TracksApi.
 * @export
 * @interface TracksApiGetByIdRequest
 */
export type TracksApiGetByIdRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiGetById
    */
    readonly trackId: number
    
    /**
    * A secret token to fetch private playlists/tracks
    * @type {string}
    * @memberof TracksApiGetById
    */
    readonly secretToken?: string
    
}

/**
 * Request parameters for getComments operation in TracksApi.
 * @export
 * @interface TracksApiGetCommentsRequest
 */
export type TracksApiGetCommentsRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiGetComments
    */
    readonly trackId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof TracksApiGetComments
    */
    readonly limit?: number
    
    /**
    * Offset of first result. Deprecated, use `linked_partitioning` instead.
    * @type {number}
    * @memberof TracksApiGetComments
    */
    readonly offset?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof TracksApiGetComments
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for getFavoriters operation in TracksApi.
 * @export
 * @interface TracksApiGetFavoritersRequest
 */
export type TracksApiGetFavoritersRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiGetFavoriters
    */
    readonly trackId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof TracksApiGetFavoriters
    */
    readonly limit?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof TracksApiGetFavoriters
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for getRelatedTracks operation in TracksApi.
 * @export
 * @interface TracksApiGetRelatedTracksRequest
 */
export type TracksApiGetRelatedTracksRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiGetRelatedTracks
    */
    readonly trackId: number
    
    /**
    * Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you\'d like to see all possible tracks. See `Track#access` schema for more details. 
    * @type {Array<'playable' | 'preview' | 'blocked'>}
    * @memberof TracksApiGetRelatedTracks
    */
    readonly access?: Array<'playable' | 'preview' | 'blocked'>
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof TracksApiGetRelatedTracks
    */
    readonly limit?: number
    
    /**
    * Offset of first result. Deprecated, use `linked_partitioning` instead.
    * @type {number}
    * @memberof TracksApiGetRelatedTracks
    */
    readonly offset?: number
    
    /**
    * Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
    * @type {boolean}
    * @memberof TracksApiGetRelatedTracks
    */
    readonly linkedPartitioning?: boolean
    
}

/**
 * Request parameters for getStreamableUrls operation in TracksApi.
 * @export
 * @interface TracksApiGetStreamableUrlsRequest
 */
export type TracksApiGetStreamableUrlsRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiGetStreamableUrls
    */
    readonly trackId: number
    
    /**
    * A secret token to fetch private playlists/tracks
    * @type {string}
    * @memberof TracksApiGetStreamableUrls
    */
    readonly secretToken?: string
    
}

/**
 * Request parameters for listReposters operation in TracksApi.
 * @export
 * @interface TracksApiListRepostersRequest
 */
export type TracksApiListRepostersRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiListReposters
    */
    readonly trackId: number
    
    /**
    * Number of results to return in the collection.
    * @type {number}
    * @memberof TracksApiListReposters
    */
    readonly limit?: number
    
}

/**
 * Request parameters for updateTrackInformation operation in TracksApi.
 * @export
 * @interface TracksApiUpdateTrackInformationRequest
 */
export type TracksApiUpdateTrackInformationRequest = {
    
    /**
    * SoundCloud Track id
    * @type {number}
    * @memberof TracksApiUpdateTrackInformation
    */
    readonly trackId: number
    
} & TrackMetadataRequest

/**
 * Request parameters for uploadNewTrack operation in TracksApi.
 * @export
 * @interface TracksApiUploadNewTrackRequest
 */
export type TracksApiUploadNewTrackRequest = {
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackTitle?: string
    
    /**
    * 
    * @type {Uint8Array | File | buffer.File}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackAssetData?: Uint8Array | File | buffer.File
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackPermalink?: string
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackSharing?: string
    
    /**
    * who can embed this track \\\"all\\\", \\\"me\\\", or \\\"none\\\"
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackEmbeddableBy?: string
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackPurchaseUrl?: string
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackDescription?: string
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackGenre?: string
    
    /**
    * The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY=VALUE. For example: geo:lat=43.555 camel:size=medium “machine:tag=with space” Machine tags are not revealed to the user on the track pages.
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackTagList?: string
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackLabelName?: string
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackRelease?: string
    
    /**
    * string, formatted as yyyy-mm-dd, representing release date
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackReleaseDate?: string
    
    /**
    * 
    * @type {boolean}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackStreamable?: boolean
    
    /**
    * 
    * @type {boolean}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackDownloadable?: boolean
    
    /**
    * Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackLicense?: string
    
    /**
    * 
    * @type {boolean}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackCommentable?: boolean
    
    /**
    * 
    * @type {string}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackIsrc?: string
    
    /**
    * 
    * @type {Uint8Array | File | buffer.File}
    * @memberof TracksApiUploadNewTrack
    */
    readonly trackArtworkData?: Uint8Array | File | buffer.File
    
} & TracksUploadNewTrackRequest

/**
 * TracksApiGenerated - object-oriented interface
 * @export
 * @class TracksApiGenerated
 * @extends {BaseAPI}
 */
export class TracksApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Returns the newly created comment on success
     * @param {TracksApiCreateCommentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public createComment(requestParameters: TracksApiCreateCommentRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).createComment(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a track.
     * @param {TracksApiDeleteTrackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public deleteTrack(requestParameters: TracksApiDeleteTrackRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).deleteTrack(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a track.
     * @param {TracksApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public getById(requestParameters: TracksApiGetByIdRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the comments posted on the track(track_id).
     * @param {TracksApiGetCommentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public getComments(requestParameters: TracksApiGetCommentsRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getComments(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of users who have favorited or liked the track.
     * @param {TracksApiGetFavoritersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public getFavoriters(requestParameters: TracksApiGetFavoritersRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getFavoriters(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all related tracks of track on SoundCloud.
     * @param {TracksApiGetRelatedTracksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public getRelatedTracks(requestParameters: TracksApiGetRelatedTracksRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getRelatedTracks(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a track\'s streamable URLs
     * @param {TracksApiGetStreamableUrlsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public getStreamableUrls(requestParameters: TracksApiGetStreamableUrlsRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).getStreamableUrls(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a collection of track\'s reposters.
     * @param {TracksApiListRepostersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public listReposters(requestParameters: TracksApiListRepostersRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).listReposters(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a track\'s information.
     * @param {TracksApiUpdateTrackInformationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public updateTrackInformation(requestParameters: TracksApiUpdateTrackInformationRequest, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).updateTrackInformation(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Uploads a new track.
     * @param {TracksApiUploadNewTrackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TracksApiGenerated
     */
    public uploadNewTrack(requestParameters: TracksApiUploadNewTrackRequest = {}, options?: AxiosRequestConfig) {
        return TracksApiFp(this.configuration).uploadNewTrack(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
